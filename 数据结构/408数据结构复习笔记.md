# 第一章 略

# 第二章 线性表

# 第三章 栈 队列和数组

# 第四章 串

# 第五章 树与二叉树

# 第六章 图

# 第七章查找
## 折半查找

### 408 折半查找

```c++
int bsearch(int a[],int l,int r,int x){
    while(l<r){
        int mid = l + r >> 1;
        if(a[mid]==x) return mid;
        else if(a[mid]>x) r=mid-1;
        else l=mid+1;
    }
    return -1;
}
```

### 非408 二分 三分

#### 整数域二分

##### 红蓝二分法

问题处理四部曲
1. 确定分界线
2. 建模:划分红蓝区域,确定isblue函数
3. 确定返回l还是r
4. 套板子

``` c++
bool isbule(double x){/* ... */} //检查x是否满足某种性质，确定分界（check函数）
	
int bsearch(int l, int r){
    while(l + 1 != r){
        int mid = l + r >> 1;
        if(isbule()) l = mid;
        else r = mid;
    }
}
```

![屏幕截图 2025-07-14 202535](https://raw.githubusercontent.com/asdfkjs/CS-408/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99/png/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-07-14%20202535.png)




#####  旧版二分（无法处理负数）

有单调性一定可以二分 可以二分不一定要有单调性

二分本质：边界

```c++
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
// 在递增序列a中查找 >= x 数中最小的一个（x或x的后继）
int bsearch_1(int l, int r,int a[])
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (a[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return a[l];
}

// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
// 在递增序列a中查找 <= x 数中最大的一个（x或x的前驱）
int bsearch_2(int l, int r,int a[])
{
    while (l < r){
        int mid = l + r + 1 >> 1;
        if (a[mid] <= x) l = mid;
        else r = mid - 1;
    }
    return a[l];
}
```

##### 新版

- $x$ 或 $x$ 的后继

```c++
int l = 0, r = 1E8, ans = r;
while (l <= r) {
    int mid = (l + r) / 2;
    if (check(mid)) {
        r = mid - 1;
        ans = mid;
    } else {
        l = mid + 1;
    }
}
return ans;
```

- $x$ 或 $x$ 的前驱

```c++
int l = 0, r = 1E8, ans = l;
while (l <= r) {
    int mid = (l + r) / 2;
    if (check(mid)) {
        l = mid + 1;
        ans = mid;
    } else {
        r = mid - 1;
    }
}
return ans;
```

#### 实数域二分

``` c++
bool check(double x){/* ... */} //检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6; //eps 表示精度，取决于题目对精度的要求
    
    while (r - l > eps){
        double mid = (l + r) / 2;
        if(check(mid)) r=mid;
        else l=mid;
    }
    return l;
}
```

目前主流的写法是限制二分次数。

```c++
for (int t = 1; t <= 100; t++) {
    ld mid = (l + r) / 2;
    if (check(mid)) r = mid;
    else l = mid;
}
cout << l << endl;
```

#### 整数域三分

```c++
while (l < r) {
    int mid = (l + r) / 2;
    if (check(mid) <= check(mid + 1)) r = mid;
    else l = mid + 1;
}
cout << check(l) << endl;
```

#### 实数域三分

限制次数实现。

```c++
ld l = -1E9, r = 1E9;
for (int t = 1; t <= 100; t++) {
    ld mid1 = (l * 2 + r) / 3;
    ld mid2 = (l + r * 2) / 3;
    if (check(mid1) < check(mid2)) {
        r = mid2;
    } else {
        l = mid1;
    }
}
cout << l << endl;
```
# 第八章 排序
## 插入排序
### 直接插入排序

```c++
//（稳定的排序） 复杂度 O(n^2)
//一个与插入排序相同的操作是打扑克牌时，从牌桌上抓一张牌，按牌面大小插到手牌后，再抓下一张牌。
void insertsort(int a[], int len) {
  //数组下标从0-（len-1) 从第二个元素开始插入 第一个元素已有序
  for (int i = 1; i < len; ++i) {
    int tmp = a[i];//待插入元素暂存
    int j = i - 1; //从待排序前一个开始 往前扫描，若大于待排序关键字，就后移一位
    while (j >= 0 && a[j] > tmp) {
      a[j + 1] = a[j];
      j--;
    }
    a[j + 1] = tmp;//插入
  }
}
```



### 折半插入排序

```c++
//（稳定的排序） 
//插入排序的优化 插入排序是 边从后往前顺序找待插入位置边后移
//而折半插入是 先二分直接找待插入位置 然后统一后移
void binsertsort(int a[], int len) {
  for (int i = 1; i < len; ++i) {
    int tmp = a[i];
    int l = 0, r = i - 1;
    while(l<=r){
      int mid = l + r >> 1;
      if(a[mid] > tmp) r = mid - 1;
      else l = mid + 1;
    }
    for(int j = i - 1; j >= l; j--) a[j+1]=a[j];//直接统一后移
    a[l]=tmp;
  }
}
```

### 希尔排序

```c++
//（不稳定的排序）
将待排序序列分为若干子序列（每个子序列的元素在原始数组中间距相同）；
对这些子序列进行插入排序;
表中元素基本有序时，再整体进行一次插入排序//减小每个子序列中元素之间的间距，重复上述过程直至间距减少为1
```

```c++
template <typename T>
void shell_sort(T a[], int length) {
  int h = 1;
  while (h < length / 3) {
    h = 3 * h + 1;
  }
  while (h >= 1) {
    for (int i = h; i < length; i++) {
      for (int j = i; j >= h && a[j] < a[j - h]; j -= h) {
        swap(a[j], a[j - h]);
      }
    }
    h = h / 3;
  }
}
```



## 交换排序

### 冒泡排序

```c++
//（稳定的排序）
//每趟都把最大的元素交换到最后 n-1趟完成排序
void bubblesort(int a[],int n){
   for(int i = 0; i < n; i++ ){
       int flag=0;
       for(int j = 1; j < n - i; j++){
           if(a[j-1] < a[j]){
               swap(a[j-1],a[j]);
               flag=1;
           }
           if(flag==0) return;
       }
   } 
}
```



### 快速排序

```c++
//（不稳定的排序） 如何变稳定：把快排里面每一个数变成二元组pair<ai,i> 然后双关键字排序即可
//先划分（最难的部分） 划分是随机的[l,r]中的值  然后再递归处理
void quick_sort(int q[], int l, int r)//分治思想 l,r左右端点下标
{
    if (l >= r) return;//区间里面没有数或者只有一个数 就不用排序直接返回
    //基准可以取[l,r] 但是在左右端点是需要修改递归参数 否则会有边界问题 严格按照模板写
    //取默认左端点情况 x = q[l]; 对应quick_sort(q, l, j), quick_sort(q, j + 1, r);
    //取中点情况 x = q[l + r >> 1]; 对应quick_sort(q, l, j), quick_sort(q, j + 1, r);
    //取右端点情况 x = q[r]; 对应quick_sort(q, l, i - 1), quick_sort(q, i, r);
    int i = l - 1, j = r + 1, x = q[l]; //本代码每次取左端点划分
    while (i < j)//一趟排序 以第一个元素基准值q[l]划分区间
    {
        do i ++ ; while (q[i] < x);//若已经小于基准 左指针后移
        do j -- ; while (q[j] > x);//若已经大于基准 右指针前移
        //此时左指针指向的数不满足小于基准，右指针指向的数不满足大于基准
        if (i < j) swap(q[i], q[j]);//于是交换左右两个数

    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);//递归处理左右两段区间
}
```

## 选择排序
### 简单选择排序

```c++
//（不稳定的排序） 复杂度 O(n^2)
//每趟选取最小的元素并确定 n-1趟后有序
void selectsort(int a[], int n) {
  for (int i = 0; i < n - 1; ++i) {
    int tmp = i;
    for (int j = i + 1; j < n; ++j) {
      if (a[j] < a[tmp]) tmp = j;//不断记录最小元素下标
    }
    swap(a[i], a[tmp]);//使当前确定位置元素为最小元素
  }
}
```



### 堆排序

#### 大根堆

```c++
//（不稳定的排序） 复杂度 O(nlogn)
//堆排序的本质是建立在堆上的选择排序。

void sift_down(int arr[], int start, int end) {
  // 计算父结点和子结点的下标
  int parent = start;
  int child = parent * 2 + 1;
  while (child <= end) {  // 子结点下标在范围内才做比较
    // 先比较两个子结点大小，选择最大的
    if (child + 1 <= end && arr[child] < arr[child + 1]) child++;
    // 如果父结点比子结点大，代表调整完毕，直接跳出函数
    if (arr[parent] >= arr[child])
      return;
    else {  // 否则交换父子内容，子结点再和孙结点比较
      swap(arr[parent], arr[child]);
      parent = child;
      child = parent * 2 + 1;
    }
  }
}

void heap_sort(int arr[], int len) {
  // 从最后一个节点的父节点开始 sift down 以完成堆化 (heapify)
  for (int i = (len - 1 - 1) / 2; i >= 0; i--) sift_down(arr, i, len - 1);
  // 先将第一个元素和已经排好的元素前一位做交换，再重新调整（刚调整的元素之前的元素），直到排序完毕
  for (int i = len - 1; i > 0; i--) {
    swap(arr[0], arr[i]);
    sift_down(arr, 0, i - 1);
  }
}
```





#### 小根堆

## 其余排序
### 归并排序

```c++
//（稳定的排序） - 双指针   
//需要辅助数组tmp 
//第一步确定分界点 一定是mid=(l+r)/2   然后递归左右   后归并-合二为一（最难的部分 复杂度 O(n) ）
//两个数组 分别一个指针 找最小的（两个数组哪个更小）然后指针后移   放进tmp数组中  
//最后未走完的数组直接补进答案数组tmp里
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];

    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
### 基数排序

```c++
//（稳定的排序）

```



### 计数排序

```c++
//（稳定的排序）

```



## 外部排序

### 败者树
### 最佳归并树

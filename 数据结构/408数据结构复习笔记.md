# 第二章 线性表

# 第三章 栈 队列和数组

# 第四章 串

# 第五章 树与二叉树

# 第六章 图

# 第七章查找
## 折半查找

### 408 折半查找

```c++
int bsearch(int a[],int l,int r,int x){
    while(l<r){
        int mid = l + r >> 1;
        if(a[mid]==x) return mid;
        else if(a[mid]>x) r=mid-1;
        else l=mid+1;
    }
    return -1;
}
```

### 非408 二分 三分

#### 整数域二分

##### 红蓝二分法

问题处理四部曲
1. 确定分界线
2. 建模:划分红蓝区域,确定isblue函数
3. 确定返回l还是r
4. 套板子

``` c++
bool isbule(double x){/* ... */} //检查x是否满足某种性质，确定分界（check函数）
	
int bsearch(int l, int r){
    while(l + 1 != r){
        int mid = l + r >> 1;
        if(isbule()) l = mid;
        else r = mid;
    }
}
```

![屏幕截图 2025-07-14 202535](https://raw.githubusercontent.com/asdfkjs/CS-408/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99/png/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-07-14%20202535.png)




#####  旧版二分（无法处理负数）

有单调性一定可以二分 可以二分不一定要有单调性

二分本质：边界

```c++
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
// 在递增序列a中查找 >= x 数中最小的一个（x或x的后继）
int bsearch_1(int l, int r,int a[])
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (a[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return a[l];
}

// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
// 在递增序列a中查找 <= x 数中最大的一个（x或x的前驱）
int bsearch_2(int l, int r,int a[])
{
    while (l < r){
        int mid = l + r + 1 >> 1;
        if (a[mid] <= x) l = mid;
        else r = mid - 1;
    }
    return a[l];
}
```

##### 新版

- $x$ 或 $x$ 的后继

```c++
int l = 0, r = 1E8, ans = r;
while (l <= r) {
    int mid = (l + r) / 2;
    if (check(mid)) {
        r = mid - 1;
        ans = mid;
    } else {
        l = mid + 1;
    }
}
return ans;
```

- $x$ 或 $x$ 的前驱

```c++
int l = 0, r = 1E8, ans = l;
while (l <= r) {
    int mid = (l + r) / 2;
    if (check(mid)) {
        l = mid + 1;
        ans = mid;
    } else {
        r = mid - 1;
    }
}
return ans;
```

#### 实数域二分

``` c++
bool check(double x){/* ... */} //检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6; //eps 表示精度，取决于题目对精度的要求
    
    while (r - l > eps){
        double mid = (l + r) / 2;
        if(check(mid)) r=mid;
        else l=mid;
    }
    return l;
}
```

目前主流的写法是限制二分次数。

```c++
for (int t = 1; t <= 100; t++) {
    ld mid = (l + r) / 2;
    if (check(mid)) r = mid;
    else l = mid;
}
cout << l << endl;
```

#### 整数域三分

```c++
while (l < r) {
    int mid = (l + r) / 2;
    if (check(mid) <= check(mid + 1)) r = mid;
    else l = mid + 1;
}
cout << check(l) << endl;
```

#### 实数域三分

限制次数实现。

```c++
ld l = -1E9, r = 1E9;
for (int t = 1; t <= 100; t++) {
    ld mid1 = (l * 2 + r) / 3;
    ld mid2 = (l + r * 2) / 3;
    if (check(mid1) < check(mid2)) {
        r = mid2;
    } else {
        l = mid1;
    }
}
cout << l << endl;
```
# 第八章 排序
## 插入排序
### 直接插入排序

```c++
//408 插入排序
void insertsort(int a[], int len) {
  for (int i = 1; i < len; ++i) {
    int tmp = a[i];
    int j = i - 1;
    while (j >= 0 && a[j] > tmp) {
      a[j + 1] = a[j];
      j--;
    }
    a[j + 1] = tmp;
  }
}
```



### 折半插入排序
### 希尔排序
## 交换排序

### 冒泡排序

### 快速排序

```c++
//408 快速排序 （不稳定的排序） 如何变稳定：把快排里面每一个数变成二元组pair<ai,i> 然后双关键字排序即可
//先划分（最难的部分） 划分是随机的[l,r]中的值  然后再递归处理
void quick_sort(int q[], int l, int r)//分治思想 l,r左右端点下标
{
    if (l >= r) return;//区间里面没有数或者只有一个数 就不用排序直接返回
    //基准可以取[l,r] 但是在左右端点是需要修改递归参数 否则会有边界问题 严格按照模板写
    //取默认左端点情况 x = q[l]; 对应quick_sort(q, l, j), quick_sort(q, j + 1, r);
    //取中点情况 x = q[l + r >> 1]; 对应quick_sort(q, l, j), quick_sort(q, j + 1, r);
    //取右端点情况 x = q[r]; 对应quick_sort(q, l, i - 1), quick_sort(q, i, r);
    int i = l - 1, j = r + 1, x = q[l]; //本代码取中点
    while (i < j)//一趟排序 以第一个元素基准值q[l]划分区间
    {
        do i ++ ; while (q[i] < x);//若已经小于基准 左指针后移
        do j -- ; while (q[j] > x);//若已经大于基准 右指针前移
        //此时左指针指向的数不满足小于基准，右指针指向的数不满足大于基准
        if (i < j) swap(q[i], q[j]);//于是交换左右两个数

    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);//递归处理左右两段区间
}
```

## 选择排序
### 简单选择排序
### 堆排序
#### 大根堆

#### 小根堆
## 其余排序
### 归并排序

```c++
//408 归并排序（稳定的排序） - 双指针   
//需要辅助数组tmp 
//第一步确定分界点 一定是mid=(l+r)/2   然后递归左右   后归并-合二为一（最难的部分 复杂度 O(n) ）
//两个数组 分别一个指针 找最小的（两个数组哪个更小）然后指针后移   放进tmp数组中  
//最后未走完的数组直接补进答案数组tmp里
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];

    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
### 基数排序
### 计数排序

## 外部排序

### 败者树
### 最佳归并树
